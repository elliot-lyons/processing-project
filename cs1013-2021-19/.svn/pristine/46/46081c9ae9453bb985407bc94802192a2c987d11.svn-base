class PieChart {

  float diameter;
  float lastAngle = 0;
  float sumOfData = 0;
  float addData;
  float mouseAngle;

  int[] data;
  float[] angles;
  float gray;
  String[] labels;
  String[] labelNames;
  color minColor, maxColor;
  float shadeOfGreen, shadeOfRed, shadeOfBlue;

  ArrayList<covidDataRow> dataList;
  String[] statesArray;
  String date;
  String percent;
  ArrayList topTenIntList;
  int[] topTenInt;
  int[] topTenSorted;
  String[] percentageSlices;
  String[] labelsForAreas;
  String nameOfState;
  HashMap<String, Integer> areaCases;

  //piechart Constructor
  PieChart(float diameter, int[] data, String[] labelNames, String nameOfState, HashMap<String, Integer> areaCases) {
    this.diameter = diameter;
    this.data = data;
    this.labelNames = labelNames;
    this.nameOfState = nameOfState;
    this.areaCases = areaCases;
    this.topTenStates();
    this.areaLabels();
    minColor = color(222, 235, 247);
    maxColor = color(49, 130, 189);
    firstTimeOnHeatMap = false;
  }

  /*
  float dataTotal(int[] data) {
   // find sum of all data
   for (int i = 0; i < data.length; i++) {
   addData = data[i];
   sumOfData += addData;
   }
   return sumOfData;
   }
   */

  void draw() {
    background(blue);
    textFont(ArialBoldItalicMtTwenty);
    /*for (int i = 0; i < labelsForAreas.length; i ++) {
     println(labelsForAreas[i]);
     }
     */

    // mapOfStates.resize(1800, 900); 
    tint(255, 180);
    // image(mapOfStates, 0, 0);
    createPieChart();
    // noLoop();
  }

  void areaLabels() {
    labelsForAreas = new String[topTenSorted.length];
    for (int i = 0; i < topTenSorted.length; i++) {
      if (areaCases.containsValue(topTenSorted[i])) {
        //println(topTenSorted[i]);
        labelsForAreas[i] = getAreaName(topTenSorted[i]);
      }
    }
  }

  String getAreaName(int valueToCheck) {
    // if you try to check an int against an Integer 
    // you should make sure the Integer is not null first btw

    for (Map.Entry<String, Integer> entry : areaCases.entrySet()) {
      if (entry.getValue() != null) {
        if (entry.getValue() == valueToCheck) {
          return entry.getKey();
        }
      }
    }
    return "null";
  }

  /*
  void createPieChart(float diameter, int[] data) {
   
   
   for (int i = 0; i < data.length; i++) {
   //addData = data[i];
   sumOfData += data[i];
   }
   //convert data to angles
   angles = new float[data.length];
   for (int i = 0; i < data.length; i++) {
   angles[i] = ((data[i] / sumOfData) * 360);
   }
   
   //draw the piechart
   int count = 0;
   shadeOfRed = 255;
   shadeOfGreen = 0;
   shadeOfBlue = 0;
   for (int i = 0; i < angles.length; i++) {
   //goes from red to yellow to green
   shadeOfGreen = i * (255/data.length * 2);
   shadeOfRed = 255;
   shadeOfBlue = 0;
   if (shadeOfGreen >= 255) {
   shadeOfRed = (255 - (i - data.length/2) * (255/data.length * 2));
   }
   fill( shadeOfRed, shadeOfGreen, shadeOfBlue);
   
   
   if (count < data.length / 3) {
   shadeOfGreen = i * (255/data.length * 3);
   }
   
   else if (count < data.length * 2 / 3 && count >= data.length / 3) {
   shadeOfRed = (255 - (i - data.length / 3) * (255 / data.length *3));
   }
   else if (count < data.length && count > data.length * 2 / 3) {
   shadeOfBlue = (i - data.length / 3 *2 ) * (255/data.length *3);
   shadeOfGreen = (255 - (i - data.length / 3 * 2) * (255 / data.length *3));
   }
   count++;
   
   
   fill(shadeOfRed, shadeOfGreen, shadeOfBlue);
   arc(width/2, height/2, diameter, diameter, lastAngle, lastAngle + radians(angles[i]));
   lastAngle += radians(angles[i]);
   //rect(420, 20 + 30 *i, 20, 200);
   if ( i < data.length / 2) {
   rect(350, 50 + 30 * i, 30, 30);
   fill(0);
   textAlign(CENTER, CENTER);
   text(labelNames[i], 350, 50 + 30 * i, 200, 20);
   } else {
   rect(1100, 50 + 30 * (i - data.length / 2), 30, 30);
   fill(0);
   textAlign(CENTER, CENTER);
   text(labelNames[i], 1100, 50 + 30 * (i - data.length/ 2), 200, 20);
   
   }
  /*
   float halfAngle = TWO_PI/10.0/3;
   float x1=width/2 + 210* cos(TWO_PI/10.0*i+halfAngle); 
   float y1=height/2  + 210* sin(TWO_PI/10.0*i+halfAngle);
   textAlign(CENTER); 
   text("Section " + i, x1, y1);
   */
  //key 
  //fill(180);
  //textAlign(CENTER, CENTER);
  //text("slice" + i, 450, 36 + 30 * i );
  /*
    }
   textAlign(LEFT, BOTTOM);
   //noLoop();
   }
   */

  void createPieChart() {
    for (int i = 0; i < topTenSorted.length; i++) {
      //addData = data[i];
      sumOfData += topTenSorted[i];
    }
    //convert data to angles
    angles = new float[topTenSorted.length];
    for (int i = 0; i < topTenSorted.length; i++) {
      angles[i] = ((topTenSorted[i] / sumOfData) * 360);
    }

    percentageSlices();

    //draw the piechart
    int count = 0;
    shadeOfRed = 255;
    shadeOfGreen = 0;
    shadeOfBlue = 0;
    for (int i = 0; i < angles.length; i++) {
      shadeOfGreen = i * (255/topTenSorted.length * 2);
      shadeOfRed = 255;
      shadeOfBlue = 0;
      if (shadeOfGreen >= 255) {
        shadeOfRed = (255 - (i - topTenSorted.length/2) * (255/topTenSorted.length * 2));
      }

      fill(shadeOfRed, shadeOfGreen, shadeOfBlue);
      arc(250, 575, diameter, diameter, lastAngle, lastAngle + radians(angles[i]));
      //    xPos,   yPos
      lastAngle += radians(angles[i]);

      rect(460, 425 + 30 * i, 30, 30);
      fill(0);
      textAlign(LEFT, CENTER);
      text(labelsForAreas[i], 560, 425 + 30 * i, 200, 30);
      text(percentageSlices[i] + "%", 500, 425 + 30 * i, 80, 30);

      //rect(350, 50 + 30 * i, 30, 30);
    }
    fill(0);
    textSize(35);
    textAlign(CENTER, CENTER);
    text("Top " + topTenSorted.length + " areas of " + nameOfState, 255, 350);
    textAlign(LEFT, BOTTOM);
  }

  void topTenStates()                                                  // this goes through each state and figures out the states with the top 3 highest cases on that day
  {
    if (data.length > 10)
    {
      topTenInt = new int[data.length];
      topTenInt = sort(data);
      topTenSorted = new int[10];
      for (int j = 0; j < 10; j++)
      {
        topTenSorted[j] = topTenInt[topTenInt.length - j - 1];
      }
    } else {
      topTenSorted = data;
    }
  }

  void percentageSlices() {
    percentageSlices = new String[topTenSorted.length];
    for (int i = 0; i < topTenSorted.length; i++) {
      float percentage = topTenSorted[i]/sumOfData * 100;
      if (percentage < 2 && percentage > 1) { // if 1.something print to 1 decimal place
        percent = nf(percentage, 0, 1);
      } else if (percentage < 1) { // if less than 1 print to 2 decimal place
        percent = nf(percentage, 0, 2);
      } else { // if greater than 2 we print the whole number
        percent = str(round(percentage));
      }
      percentageSlices[i] = percent;
    }
  }
}
